# -*- coding: utf-8 -*-
"""Reporter for benchmark results using graphs."""
from __future__ import annotations
from argparse import Namespace
from copy import deepcopy
from io import BytesIO, BufferedWriter
from pathlib import Path
from typing import Optional, Literal, Iterable, Any, TYPE_CHECKING

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from simplebench.defaults import BASE_INTERVAL_UNIT, BASE_OPS_PER_INTERVAL_UNIT
from simplebench.enums import Section, Target, Format, FlagType
from simplebench.exceptions import SimpleBenchTypeError, SimpleBenchValueError
from simplebench.metaclasses import ICase
from simplebench.results import Results
from simplebench.si_units import si_scale_for_smallest
from simplebench.utils import sanitize_filename
from simplebench.validators import (validate_sequence_of_type, validate_non_blank_string, validate_positive_int,
                                    validate_int_range)
from ..choices import Choice, Choices, ChoiceOptions
from ..exceptions.graph.scatter import (ScatterPlotReporterErrorTag, ScatterPlotOptionsErrorTag,
                                        ScatterPlotChoiceOptionsErrorTag)
from ..interfaces import Reporter, ReporterCallback
from ..reporter_option import ReporterOption
from .enums import ImageType

if TYPE_CHECKING:
    from simplebench.case import Case
    from simplebench.session import Session


SUPPORTED_IMAGE_TYPES: set[ImageType] = {ImageType.SVG, ImageType.PNG}

DEFAULT_GRAPH_THEME: dict[str, Any] = {
    'axes.grid': True,
    'grid.linestyle': '-',
    'grid.color': '#444444',
    'legend.framealpha': 1,
    'legend.shadow': True,
    'legend.fontsize': 14,
    'legend.title_fontsize': 16,
    'xtick.labelsize': 12,
    'ytick.labelsize': 12,
    'axes.labelsize': 16,
    'axes.titlesize': 20,
    'figure.dpi': 100}
"""Default theme for graphs.

This theme is applied to all graphs generated by the ScatterPlotReporter unless overridden
by a ScatterPlotOptions instance provided in the Case options.

Options are those used by matplotlib and seaborn. See the following for more details:
- https://matplotlib.org/stable/tutorials/introductory/customizing.html
- https://matplotlib.org/stable/users/explain/customizing.html#the-matplotlibrc-file

Default values:

    {
        'axes.grid': True,
        'grid.linestyle': '-',
        'grid.color': '#444444',
        'legend.framealpha': 1,
        'legend.shadow': True,
        'legend.fontsize': 14,
        'legend.title_fontsize': 16,
        'xtick.labelsize': 12,
        'ytick.labelsize': 12,
        'axes.labelsize': 16,
        'axes.titlesize': 20,
        'figure.dpi': 100
    }
"""


class ScatterPlotOptions(ReporterOption):
    """Container for graphing options for ScatterPlotReporter specified in tests.

    This class holds configuration options for graph generation, such as style,
    aspect ratio, and axis settings. It can be extended in the future to include
    additional graphing options as needed.

    It also functions as the default values for graphing options in the ScatterPlotReporter.

    Default theme:
        {
            'axes.grid': True,
            'grid.linestyle': '-',
            'grid.color': '#444444',
            'legend.framealpha': 1,
            'legend.shadow': True,
            'legend.fontsize': 14,
            'legend.title_fontsize': 16,
            'xtick.labelsize': 12,
            'ytick.labelsize': 12,
            'axes.labelsize': 16,
            'axes.titlesize': 20,
            'figure.dpi': 100}
        }

    Args:
        theme (Optional[dict[str, Any]]): The theme to use for the graphs. If None, the default theme will be used.
        style (Literal['dark_background', 'default'], default='dark_background'): The style to use for the graphs.
            See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html
        aspect_ratio (float, default=1.6): The aspect ratio (width / height) to use for the graphs.
            Must be a positive number.
        y_starts_at_zero (bool, default=True): Whether the y-axis should start at zero.
        x_labels_rotation (float, default=45.0): The rotation angle (in degrees) for x-axis labels.
        output_format (ImageType, default=ImageType.SVG): The output format for the graph files.
    """
    def __init__(self,
                 theme: Optional[dict[str, Any]] = None,
                 style: Literal['dark_background', 'default'] = 'dark_background',
                 aspect_ratio: float = 1.6,
                 y_starts_at_zero: bool = True,
                 x_labels_rotation: float = 45.0,
                 output_format: ImageType = ImageType.SVG) -> None:
        """Initialize a ScatterPlotOptions instance with the provided settings.

        Args:
            theme (Optional[dict[str, Any]]): The theme to use for the graphs. If None, the default theme will be used.
            style (Literal['dark_background', 'default']): The style to use for the graphs.
                See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html
                Default is 'dark_background'.
            aspect_ratio (float): The aspect ratio (width / height) to use for the graphs.
                Must be a positive number. Default is 1.6.
            y_starts_at_zero (bool): Whether the y-axis should start at zero. Default is True.
            x_labels_rotation (float): The rotation angle (in degrees) for x-axis labels. Default is 45.0.
            output_format (ImageType): The output format for the graph files. Default is `ImageType.SVG`.
        """
        if theme is None:
            # Use a copy of the default theme to avoid accidental modifications of the global default
            theme = deepcopy(DEFAULT_GRAPH_THEME)
        if not isinstance(theme, dict):
            raise SimpleBenchTypeError(
                f"theme must be a dict not a {type(theme)}",
                tag=ScatterPlotOptionsErrorTag.INVALID_THEME_TYPE)
        self.theme: dict[str, Any] = theme
        """The theme to use for the graphs."""

        if style not in ['dark_background', 'default']:
            raise SimpleBenchValueError(
                f"Unsupported style: {style}. Supported styles are 'dark_background' and 'default'.",
                tag=ScatterPlotOptionsErrorTag.UNSUPPORTED_STYLE)
        self.style: str = style
        """The style to use for the graphs.
        See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html"""

        if aspect_ratio <= 0:
            raise SimpleBenchValueError(
                "Aspect ratio must be a positive number",
                tag=ScatterPlotOptionsErrorTag.INVALID_ASPECT_RATIO)
        self.aspect_ratio: float = aspect_ratio
        """The aspect ratio (width / height) to use for the graphs."""

        if not isinstance(y_starts_at_zero, bool):
            raise SimpleBenchTypeError(
                f"y_starts_at_zero must be a bool not a {type(y_starts_at_zero)}",
                tag=ScatterPlotOptionsErrorTag.INVALID_Y_STARTS_AT_ZERO_TYPE)
        self.y_starts_at_zero: bool = y_starts_at_zero
        """Whether the y-axis should start at zero."""

        if not isinstance(x_labels_rotation, float):
            raise SimpleBenchTypeError(
                f"x_labels_rotation must be a float not a {type(x_labels_rotation)}",
                tag=ScatterPlotOptionsErrorTag.INVALID_X_LABELS_ROTATION_TYPE)
        self.x_labels_rotation: float = x_labels_rotation
        """The rotation angle (in degrees) for x-axis labels."""

        if output_format not in SUPPORTED_IMAGE_TYPES:
            raise SimpleBenchValueError(
                f"Unsupported output format: {output_format}. "
                f"Supported formats are: {SUPPORTED_IMAGE_TYPES}.",
                tag=ScatterPlotOptionsErrorTag.UNSUPPORTED_OUTPUT_FORMAT)
        self.output_format: ImageType = output_format
        """The output format for the graph files. ImageType.SVG by default."""


class GraphChoiceOptions(ChoiceOptions):
    """Base class for holding Graph reporter specific options in a Choice."""


class ScatterPlotChoiceOptions(GraphChoiceOptions):
    """Class for holding Scatter graph reporter specific options in a Choice.

    This class provides additional configuration options specific to the ScatterPlot reporter.
    It is accessed via the `options` attribute of a Choice instance.

    Attributes:
        default_targets (frozenset[Target]): The default targets for the ScatterPlot reporter choice.
        subdir (str): The subdirectory to output ScatterPlot files to.
        default_width (int, default=1500): The width of the ScatterPlot output when rendered to the
                filesystem or via callback.
        default_height (int, default=750): The height of the ScatterPlot output when rendered to the
                filesystem or via callback.
    """
    def __init__(self,
                 default_targets: Iterable[Target],
                 subdir: str = 'graphs',
                 default_width: int = 1500,
                 default_height: int = 750,
                 default_dpi: int = 100) -> None:
        """Initialize ScatterPlotChoiceOptions with default targets and subdirectory.

        Args:
            default_targets (Iterable[Target]): The default targets for the Rich table reporter choice.
            subdir (str, default='json'): The subdirectory to output Rich table files to.
            default_width (int, default=1500): The width of the ScatterPlot output when rendered to the filesystem
                    or via callback.
            default_height (int, default=750): The height of the ScatterPlot output when rendered to the filesystem
                    or via callback.
            default_dpi (int, default=100): The default DPI (dots per inch) for the ScatterPlot output.
        """
        if not isinstance(default_targets, Iterable):
            raise SimpleBenchValueError(
                'ScatterPlotChoiceOptions.default_targets must be an iterable of Target values.',
                tag=ScatterPlotChoiceOptionsErrorTag.DEFAULT_TARGETS_NOT_ITERABLE)
        default_targets = validate_sequence_of_type(
                list(default_targets), Target, 'ScatterPlotChoiceOptions.default_targets',
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_TARGETS_TYPE,
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_TARGETS_VALUE,
                allow_empty=False)
        self._default_targets: frozenset[Target] = frozenset(default_targets)
        self._subdir: str = validate_non_blank_string(
                subdir, 'ScatterPlotChoiceOptions.subdir',
                ScatterPlotChoiceOptionsErrorTag.INVALID_SUBDIR_TYPE,
                ScatterPlotChoiceOptionsErrorTag.INVALID_SUBDIR_VALUE)
        self._default_width: int = validate_positive_int(
                default_width, 'ScatterPlotChoiceOptions.default_width',
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_WIDTH_TYPE,
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_WIDTH_VALUE)
        self._default_height: int = validate_positive_int(
                default_height, 'ScatterPlotChoiceOptions.default_height',
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_HEIGHT_TYPE,
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_HEIGHT_VALUE)
        self._default_dpi: int = validate_int_range(
                default_dpi, 'ScatterPlotChoiceOptions.default_dpi',
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_DPI_TYPE,
                ScatterPlotChoiceOptionsErrorTag.INVALID_DEFAULT_DPI_VALUE,
                min_value=75, max_value=400)

    @property
    def default_targets(self) -> frozenset[Target]:
        """Return the default targets for the ScatterPlot reporter choice.

        Returns:
            frozenset[Target]: The default targets for the ScatterPlot reporter choice.
        """
        return self._default_targets

    @property
    def subdir(self) -> str:
        """Return the subdirectory to output ScatterPlot files to.

        Returns:
            str: The subdirectory to output ScatterPlot files to (default is 'rich').
        """
        return self._subdir

    @property
    def default_width(self) -> int:
        """Return the default_width in pixels of the graph when rendered.

        Returns:
            int: The default width of the graph when rendered.
        """
        return self._default_width

    @property
    def default_height(self) -> int:
        """Return the default_height in pixels of the graph when rendered.

        Returns:
            int: The default height of the graph when rendered.
        """
        return self._default_height

    @property
    def default_dpi(self) -> int:
        """Return the default_dpi of the graph when rendered.

        Returns:
            int: The default DPI of the graph when rendered.
        """
        return self._default_dpi


class ScatterPlotReporter(Reporter):
    """Class for outputting benchmark results as graphs."""

    DEFAULT_TARGETS: list[Target] = [Target.FILESYSTEM]
    """Default targets for the Graph reporter."""

    def __init__(self) -> None:
        super().__init__(
            name='graph',
            description='Outputs benchmark results as graphs.',
            sections={Section.OPS, Section.TIMING, Section.MEMORY, Section.PEAK_MEMORY},
            targets={Target.FILESYSTEM, Target.CALLBACK},
            formats={Format.GRAPH},
            choices=Choices([
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-file'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-file',
                    description='Save a scatter graph of operations per second results to a file',
                    sections=[Section.OPS, Section.TIMING, Section.MEMORY, Section.PEAK_MEMORY],
                    targets=[Target.FILESYSTEM],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-ops.file'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-ops-file',
                    description='Save a scatter graph of operations per second results to a file',
                    sections=[Section.OPS],
                    targets=[Target.FILESYSTEM],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-timings.file'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-timings-file',
                    description='Save a scatter graph of timing results to a file',
                    sections=[Section.TIMING],
                    targets=[Target.FILESYSTEM],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-memory.file'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-memory-file',
                    description='Save scatter graphs of memory usage to files',
                    sections=[Section.MEMORY, Section.PEAK_MEMORY],
                    targets=[Target.FILESYSTEM],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter.callback'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-callback',
                    description='Return scatter graph of operations per second results to a callback function',
                    sections=[Section.OPS, Section.TIMING, Section.MEMORY, Section.PEAK_MEMORY],
                    targets=[Target.CALLBACK],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-ops.callback'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-ops-callback',
                    description='Return scatter graph of operations per second results to a callback function',
                    sections=[Section.OPS],
                    targets=[Target.CALLBACK],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-timings.callback'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-timings-callback',
                    description='Return scatter graph of timing results to a callback function',
                    sections=[Section.TIMING],
                    targets=[Target.CALLBACK],
                    formats=[Format.GRAPH]),
                Choice(
                    reporter=self,
                    flags=['--graph-scatter-memory.callback'],
                    flag_type=FlagType.BOOLEAN,
                    name='graph-scatter-memory-callback',
                    description='Return scatter graphs of memory usage to a callback function',
                    sections=[Section.MEMORY, Section.PEAK_MEMORY],
                    targets=[Target.CALLBACK],
                    formats=[Format.GRAPH]),
            ])
        )

    def run_report(self,
                   *,
                   args: Namespace,
                   case: Case,
                   choice: Choice,
                   path: Path | None = None,
                   session: Session | None = None,  # pylint: disable=unused-argument
                   callback: ReporterCallback | None = None
                   ) -> None:
        """Output the benchmark results as graphs.

        This method is called by the base class's report() method after validation. The base class
        handles validation of the arguments, so subclasses can assume the arguments
        are valid without a large amount of boilerplate code. The base class also handles lazy
        loading of the reporter classes, so subclasses can assume any required imports are available

        Args:
            args (Namespace): The parsed command-line arguments.
            case (Case): The Case instance representing the benchmarked code.
            choice (Choice): The Choice instance specifying the report configuration.
            path (Optional[Path]): The path to the directory where the CSV file(s) will be saved.
            session (Optional[Session]): The Session instance containing benchmark results.
            callback (Optional[Callable[[Case, Section, Format, Any], None]]):
                A callback function for additional processing of the report.
                The function should accept two arguments: the Case instance and the graph data.
                Leave as None if no callback is needed.

        Return:
            None

        Raises:
            SimpleBenchTypeError: If the provided arguments are not of the expected types or if
                required arguments are missing. Also raised if the callback is not callable
                when provided for a CALLBACK target or if the path is not a Path instance when
                a FILESYSTEM target is specified.
            SimpleBenchValueError: If an unsupported section or target is specified in the choice.
        """
        output_format: ImageType = ImageType.SVG
        if case.options is not None:
            for item in case.options:
                if isinstance(item, ScatterPlotOptions):
                    output_format = item.output_format
                    break
        if output_format not in SUPPORTED_IMAGE_TYPES:
            raise SimpleBenchValueError(
                f"Unsupported output format: {output_format}. "
                f"Supported formats are {SUPPORTED_IMAGE_TYPES}.",
                tag=ScatterPlotReporterErrorTag.RUN_REPORT_UNSUPPORTED_OUTPUT_FORMAT)

        for section in choice.sections:
            base_unit: str = ''
            if section is Section.OPS:
                base_unit = BASE_OPS_PER_INTERVAL_UNIT
            elif section is Section.TIMING:
                base_unit = BASE_INTERVAL_UNIT
            else:  # This should never happen due to earlier validation
                raise SimpleBenchValueError(
                    f"Unsupported section: {section} (this should not happen)",
                    tag=ScatterPlotReporterErrorTag.RUN_REPORT_UNSUPPORTED_SECTION)

            filename: str = sanitize_filename(section.value)
            if Target.FILESYSTEM in choice.targets:
                file = path.joinpath(  # type: ignore[reportOptionalMemberAccess, union-attr]
                    'graph', f'{filename}.{output_format}')
                file.parent.mkdir(parents=True, exist_ok=True)
                with file.open(mode='wb') as graphfile:
                    self._plot_graph(case=case, section=section, graphfile=graphfile, base_unit=base_unit)
                    graphfile.close()
            if Target.CALLBACK in choice.targets and case.callback is not None:
                with BytesIO() as graphfile:
                    self._plot_graph(case=case, section=section, graphfile=graphfile, base_unit=base_unit)
                    graphfile.seek(0)
                    case.callback(case=case, section=section, output_format=Format.GRAPH, output=graphfile.read())
                    graphfile.close()

    def _plot_graph(self,
                    *,
                    case: Case,
                    section: Section,
                    graphfile: BytesIO | BufferedWriter,
                    base_unit: str = '') -> None:
        """Generates and saves a scatter plot of results.

        Args:
            case (Case): The Case instance representing the benchmarked code.
            section (Section): The section of the results to plot. Must be Section.OPS or Section.TIMING.
            graphfile (BytesIO | BufferedWriter): The file-like object to save the graph to.
            base_unit (str): The base unit for the y-axis.

        Raises:
            SimpleBenchTypeError: If the provided arguments are not of the expected types or values.
            SimpleBenchValueError: If the provided values are not valid.

        Returns:
            None
        """
        if not isinstance(case, ICase):
            raise SimpleBenchTypeError(
                "Expected a Case instance",
                tag=ScatterPlotReporterErrorTag.PLOT_GRAPH_INVALID_CASE_ARG)

        if not isinstance(graphfile, (BytesIO, BufferedWriter)):
            raise SimpleBenchTypeError(
                "Expected a BytesIO or BufferedWriter instance",
                tag=ScatterPlotReporterErrorTag.PLOT_GRAPH_INVALID_GRAPHPATH_ARG)

        if not isinstance(section, Section) or section not in [Section.OPS, Section.TIMING]:
            raise SimpleBenchTypeError(
                "section must be either Section.OPS or Section.TIMING",
                tag=ScatterPlotReporterErrorTag.PLOT_GRAPH_INVALID_SECTION_ARG)

        results: list[Results] = case.results
        if not results:
            return

        all_numbers: list[float] = []
        all_numbers.extend([result.results_section(section).mean for result in results])
        common_unit, common_scale = si_scale_for_smallest(numbers=all_numbers, base_unit=base_unit)
        target_name = f'{section.value} ({base_unit})'

        options = ScatterPlotOptions()  # Default options
        output_format = ImageType.SVG
        if case.options is not None:
            for item in case.options:
                if isinstance(item, ScatterPlotOptions):
                    options = item
                    break
        output_format = options.output_format

        # Prepare data for plotting
        plot_data = []
        x_axis_legend = '\n'.join([f"{case.variation_cols.get(k, k)}"
                                   for k in case.variation_cols.keys()])
        for result in results:
            target_stats = result.results_section(section)
            variation_label = '\n'.join([f"{v}" for v in result.variation_marks.values()])
            plot_data.append({
                x_axis_legend: variation_label,
                target_name: target_stats.mean * common_scale,
            })

        if not plot_data:
            return

        # See https://matplotlib.org/stable/users/explain/customizing.html#the-matplotlibrc-file
        benchmarking_theme = options.theme
        mpl.rcParams.update(benchmarking_theme)
        df = pd.DataFrame(plot_data)

        # Create the plot
        plt.style.use(options.style)
        g = sns.relplot(data=df, y=target_name, x=x_axis_legend)
        g.figure.suptitle(case.title, fontsize='large', weight='bold')
        g.figure.subplots_adjust(top=.9)
        g.figure.set_dpi(160)  # dots per inch
        g.figure.set_figheight(10)  # inches
        g.figure.set_figwidth(10 * options.aspect_ratio)
        g.tick_params("x", rotation=options.x_labels_rotation)
        # format the labels with f-strings
        for ax in g.axes.flat:
            ax.yaxis.set_major_formatter('{x}' + f' {common_unit}')
        if options.y_starts_at_zero:
            _, top = plt.ylim()
            plt.ylim(bottom=0, top=top * 1.10)  # Add 10% headroom
        plt.savefig(graphfile, format=output_format)
        plt.close()  # Close the figure to free memory
        graphfile.flush()
