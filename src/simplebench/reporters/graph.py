# -*- coding: utf-8 -*-
"""Reporter for benchmark results using graphs."""
from __future__ import annotations
from argparse import ArgumentParser
from copy import deepcopy
from io import BytesIO, BufferedWriter
from pathlib import Path
from typing import Optional, Callable, Literal, Any, TYPE_CHECKING

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from ..constants import BASE_INTERVAL_UNIT, BASE_OPS_PER_INTERVAL_UNIT
from ..enums import Section
from ..exceptions import SimpleBenchTypeError, SimpleBenchValueError, ErrorTag
from ..results import Results
from .reporter_option import ReporterOption
from ..utils import sanitize_filename, si_scale_for_smallest
from .choices import Choice, Choices, Format, Target
from .interfaces import Reporter
if TYPE_CHECKING:
    from ..case import Case
    from ..session import Session

_lazy_classes_loaded: bool = False


def _lazy_load_classes() -> None:
    """Lazy load classes to avoid circular import issues."""
    global Case, _lazy_classes_loaded  # pylint: disable=global-statement
    if not _lazy_classes_loaded:
        from ..case import Case  # pylint: disable=import-outside-toplevel
        _lazy_classes_loaded = True


DEFAULT_GRAPH_THEME: dict[str, Any] = {
    'axes.grid': True,
    'grid.linestyle': '-',
    'grid.color': '#444444',
    'legend.framealpha': 1,
    'legend.shadow': True,
    'legend.fontsize': 14,
    'legend.title_fontsize': 16,
    'xtick.labelsize': 12,
    'ytick.labelsize': 12,
    'axes.labelsize': 16,
    'axes.titlesize': 20,
    'figure.dpi': 100}
"""Default theme for graphs.

This theme is applied to all graphs generated by the GraphReporter unless overridden
by a GraphOptions instance provided in the Case options.

{
    'axes.grid': True,
    'grid.linestyle': '-',
    'grid.color': '#444444',
    'legend.framealpha': 1,
    'legend.shadow': True,
    'legend.fontsize': 14,
    'legend.title_fontsize': 16,
    'xtick.labelsize': 12,
    'ytick.labelsize': 12,
    'axes.labelsize': 16,
    'axes.titlesize': 20,
    'figure.dpi': 100
}
"""


class GraphOptions(ReporterOption):
    """Container for graphing options for GraphReporter.

    This class holds configuration options for graph generation, such as style,
    aspect ratio, and axis settings. It can be extended in the future to include
    additional graphing options as needed.

    It also functions as the default values for graphing options in the GraphReporter.

    Default theme:
        {
            'axes.grid': True,
            'grid.linestyle': '-',
            'grid.color': '#444444',
            'legend.framealpha': 1,
            'legend.shadow': True,
            'legend.fontsize': 14,
            'legend.title_fontsize': 16,
            'xtick.labelsize': 12,
            'ytick.labelsize': 12,
            'axes.labelsize': 16,
            'axes.titlesize': 20,
            'figure.dpi': 100}
        }

    Args:
       theme (Optional[dict[str, Any]]): The theme to use for the graphs. If None, the default theme will be used.
        style (Literal['dark_background', 'default']): The style to use for the graphs.
            See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html
            Default is 'dark_background'.
        aspect_ratio (float): The aspect ratio (width / height) to use for the graphs.
            Must be a positive number. Default is 1.6.
        y_starts_at_zero (bool): Whether the y-axis should start at zero. Default is True.
        x_labels_rotation (float): The rotation angle (in degrees) for x-axis labels. Default is 45.0.
        output_format (Literal['svg', 'png']): The output format for the graph files. Default is 'svg'.
    """
    def __init__(self,
                 theme: Optional[dict[str, Any]] = None,
                 style: Literal['dark_background', 'default'] = 'dark_background',
                 aspect_ratio: float = 1.6,
                 y_starts_at_zero: bool = True,
                 x_labels_rotation: float = 45.0,
                 output_format: Literal['svg', 'png'] = 'svg') -> None:
        """Initialize GraphOptions with the provided settings.

        Args:
            theme (Optional[dict[str, Any]]): The theme to use for the graphs. If None, the default theme will be used.
            style (Literal['dark_background', 'default']): The style to use for the graphs.
                See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html
                Default is 'dark_background'.
            aspect_ratio (float): The aspect ratio (width / height) to use for the graphs.
                Must be a positive number. Default is 1.6.
            y_starts_at_zero (bool): Whether the y-axis should start at zero. Default is True.
            x_labels_rotation (float): The rotation angle (in degrees) for x-axis labels. Default is 45.0.
            output_format (Literal['svg', 'png']): The output format for the graph files. Default is 'svg'.
        """
        if theme is None:
            # Use a copy of the default theme to avoid accidental modifications of the global default
            theme = deepcopy(DEFAULT_GRAPH_THEME)
        if not isinstance(theme, dict):
            raise SimpleBenchTypeError(
                f"theme must be a dict not a {type(theme)}",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_INVALID_THEME_TYPE)
        self.theme: dict[str, Any] = theme
        """The theme to use for the graphs."""

        if style not in ['dark_background', 'default']:
            raise SimpleBenchValueError(
                f"Unsupported style: {style}. Supported styles are 'dark_background' and 'default'.",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_UNSUPPORTED_STYLE)
        self.style: str = style
        """The style to use for the graphs.
        See https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html"""

        if aspect_ratio <= 0:
            raise SimpleBenchValueError(
                "Aspect ratio must be a positive number",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_INVALID_ASPECT_RATIO)
        self.aspect_ratio: float = aspect_ratio
        """The aspect ratio (width / height) to use for the graphs."""

        if not isinstance(y_starts_at_zero, bool):
            raise SimpleBenchTypeError(
                f"y_starts_at_zero must be a bool not a {type(y_starts_at_zero)}",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_INVALID_Y_STARTS_AT_ZERO_TYPE)
        self.y_starts_at_zero: bool = y_starts_at_zero
        """Whether the y-axis should start at zero."""

        if not isinstance(x_labels_rotation, float):
            raise SimpleBenchTypeError(
                f"x_labels_rotation must be a float not a {type(x_labels_rotation)}",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_INVALID_X_LABELS_ROTATION_TYPE)
        self.x_labels_rotation: float = x_labels_rotation
        """The rotation angle (in degrees) for x-axis labels."""

        if output_format not in ['svg', 'png']:
            raise SimpleBenchValueError(
                f"Unsupported output format: {output_format}. Supported formats are 'svg' and 'png'.",
                ErrorTag.GRAPH_REPORTER_GRAPH_OPTIONS_UNSUPPORTED_OUTPUT_FORMAT)
        self.output_format: Literal['svg', 'png'] = output_format
        """The output format for the graph files. SVG by default."""


class GraphReporter(Reporter):
    """Class for outputting benchmark results as graphs."""
    def __init__(self) -> None:
        self._choices: Choices = Choices()
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-file'],
                name='graph-scatter-file',
                description='Save a scatter graph of operations per second results to a file',
                sections=[Section.OPS, Section.TIMING],
                targets=[Target.FILESYSTEM],
                formats=[Format.GRAPH]))
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-ops-file'],
                name='graph-scatter-ops-file',
                description='Save a scatter graph of operations per second results to a file',
                sections=[Section.OPS],
                targets=[Target.FILESYSTEM],
                formats=[Format.GRAPH]))
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-timings-file'],
                name='graph-scatter-timings-file',
                description='Save a scatter graph of timing results to a file',
                sections=[Section.TIMING],
                targets=[Target.FILESYSTEM],
                formats=[Format.GRAPH])
        )
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-callback'],
                name='graph-scatter-callback',
                description='Return scatter graph of operations per second results to a callback function',
                sections=[Section.OPS, Section.TIMING],
                targets=[Target.CALLBACK],
                formats=[Format.GRAPH]))
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-ops-callback'],
                name='graph-scatter-ops-callback',
                description='Return scatter graph of operations per second results to a callback function',
                sections=[Section.OPS],
                targets=[Target.CALLBACK],
                formats=[Format.GRAPH]))
        self._choices.add(
            Choice(
                reporter=self,
                flags=['--graph-scatter-timings-callback'],
                name='graph-scatter-timings-callback',
                description='Return scatter graph of timing results to a callback function',
                sections=[Section.TIMING],
                targets=[Target.CALLBACK],
                formats=[Format.GRAPH])
        )

    def supported_formats(self):
        """Return the set of supported output formats for the reporter."""
        return set([Format.GRAPH])

    def supported_sections(self):
        """Return the set of supported result sections for the reporter."""
        return set([Section.OPS, Section.TIMING])

    def supported_targets(self):
        """Return the set of supported output targets for the reporter."""
        return set([Target.FILESYSTEM, Target.CALLBACK])

    @property
    def choices(self) -> Choices:
        """Return the Choices instance for the reporter, including sections,
        output targets, and formats.
        """
        return self._choices

    @property
    def name(self) -> str:
        """Return the unique identifying registration name of the reporter."""
        return 'graph'

    @property
    def description(self) -> str:
        """Return a brief description of the reporter."""
        return 'Outputs benchmark results as graphs.'

    def add_flags_to_argparse(self, parser: ArgumentParser) -> None:
        """Add the reporter's command-line flags to an ArgumentParser.

        Args:
            parser (ArgumentParser): The ArgumentParser to add the flags to.
        """
        for choice in self.choices.values():
            for flag in choice.flags:
                parser.add_argument(flag, action='store_true', help=choice.description)

    def run_report(self,
                   case: Case,
                   choice: Choice,
                   path: Optional[Path] = None,
                   session: Optional[Session] = None,  # pylint: disable=unused-argument
                   callback: Optional[Callable[[Case, Section, Format, Any], None]] = None
                   ) -> None:
        """Output the benchmark results as graphs.

        This method is called by the base class's report() method after validation. The base class
        handles validation of the arguments, so subclasses can assume the arguments
        are valid without a large amount of boilerplate code. The base class also handles lazy
        loading of the reporter classes, so subclasses can assume any required imports are available

        Args:
            case (Case): The Case instance representing the benchmarked code.
            choice (Choice): The Choice instance specifying the report configuration.
            path (Optional[Path]): The path to the directory where the CSV file(s) will be saved.
            session (Optional[Session]): The Session instance containing benchmark results.
            callback (Optional[Callable[[Case, Section, Format, Any], None]]):
                A callback function for additional processing of the report.
                The function should accept two arguments: the Case instance and the graph data.
                Leave as None if no callback is needed.

        Return:
            None

        Raises:
            SimpleBenchTypeError: If the provided arguments are not of the expected types or if
                required arguments are missing. Also raised if the callback is not callable
                when provided for a CALLBACK target or if the path is not a Path instance when
                a FILESYSTEM target is specified.
            SimpleBenchValueError: If an unsupported section or target is specified in the choice.
        """
        _lazy_load_classes()
        output_format: str = 'svg'
        if case.options is not None:
            for item in case.options:
                if isinstance(item, GraphOptions):
                    output_format = item.output_format
                    break
        if output_format not in ['svg', 'png']:
            raise SimpleBenchValueError(
                f"Unsupported output format: {output_format}. Supported formats are 'svg' and 'png'.",
                ErrorTag.GRAPH_REPORTER_RUN_REPORT_UNSUPPORTED_OUTPUT_FORMAT)

        for section in choice.sections:
            base_unit: str = ''
            if section is Section.OPS:
                base_unit = BASE_OPS_PER_INTERVAL_UNIT
            elif section is Section.TIMING:
                base_unit = BASE_INTERVAL_UNIT
            else:  # This should never happen due to earlier validation
                raise SimpleBenchValueError(
                    f"Unsupported section: {section} (this should not happen)",
                    ErrorTag.GRAPH_REPORTER_REPORT_UNSUPPORTED_SECTION)

            filename: str = sanitize_filename(section.value)
            if Target.FILESYSTEM in choice.targets:
                file = path.joinpath(  # type: ignore[reportOptionalMemberAccess, union-attr]
                    'graph', f'{filename}.{output_format}')
                file.parent.mkdir(parents=True, exist_ok=True)
                with file.open(mode='wb') as graphfile:
                    self._plot_graph(case=case, section=section, graphfile=graphfile, base_unit=base_unit)
                    graphfile.close()
            if Target.CALLBACK in choice.targets and case.callback is not None:
                with BytesIO() as graphfile:
                    self._plot_graph(case=case, section=section, graphfile=graphfile, base_unit=base_unit)
                    graphfile.seek(0)
                    case.callback(case, section, Format.GRAPH, graphfile.read())
                    graphfile.close()

    def _plot_graph(self,
                    case: Case,
                    section: Section,
                    graphfile: BytesIO | BufferedWriter,
                    base_unit: str = '') -> None:
        """Generates and saves a scatter plot of the ops/sec and/or round timings results.

        Args:
            case (Case): The Case instance representing the benchmarked code.
            section (Section): The section of the results to plot. Must be Section.OPS or Section.TIMING.
            graphfile (BytesIO | BufferedWriter): The file-like object to save the graph to.
            base_unit (str): The base unit for the y-axis.

        Raises:
            SimpleBenchTypeError: If the provided arguments are not of the expected types or values.
            SimpleBenchValueError: If the provided values are not valid.

        Returns:
            None
        """
        _lazy_load_classes()
        if not isinstance(case, Case):
            raise SimpleBenchTypeError(
                "Expected a Case instance",
                ErrorTag.GRAPH_REPORTER_PLOT_INVALID_CASE_ARG)

        if not isinstance(graphfile, (BytesIO, BufferedWriter)):
            raise SimpleBenchTypeError(
                "Expected a BytesIO or BufferedWriter instance",
                ErrorTag.GRAPH_REPORTER_PLOT_INVALID_GRAPHPATH_ARG)

        if not isinstance(section, Section) or section not in [Section.OPS, Section.TIMING]:
            raise SimpleBenchTypeError(
                "section must be either Section.OPS or Section.TIMING",
                ErrorTag.GRAPH_REPORTER_PLOT_INVALID_SECTION_ARG)

        results: list[Results] = case.results
        if not results:
            return

        all_numbers: list[float] = []
        all_numbers.extend([result.results_section(section).mean for result in results])
        common_unit, common_scale = si_scale_for_smallest(numbers=all_numbers, base_unit=base_unit)
        target_name = f'{section.value} ({base_unit})'

        options = GraphOptions()  # Default options
        output_format = 'svg'
        if case.options is not None:
            for item in case.options:
                if isinstance(item, GraphOptions):
                    options = item
                    break
        output_format = options.output_format

        # Prepare data for plotting
        plot_data = []
        x_axis_legend = '\n'.join([f"{case.variation_cols.get(k, k)}"
                                   for k in case.variation_cols.keys()])
        for result in results:
            target_stats = result.results_section(section)
            variation_label = '\n'.join([f"{v}" for v in result.variation_marks.values()])
            plot_data.append({
                x_axis_legend: variation_label,
                target_name: target_stats.mean * common_scale,
            })

        if not plot_data:
            return

        # See https://matplotlib.org/stable/users/explain/customizing.html#the-matplotlibrc-file
        benchmarking_theme = options.theme
        mpl.rcParams.update(benchmarking_theme)
        df = pd.DataFrame(plot_data)

        # Create the plot
        plt.style.use(options.style)
        g = sns.relplot(data=df, y=target_name, x=x_axis_legend)
        g.figure.suptitle(case.title, fontsize='large', weight='bold')
        g.figure.subplots_adjust(top=.9)
        g.figure.set_dpi(160)
        g.figure.set_figheight(10)
        g.figure.set_figwidth(10 * options.aspect_ratio)
        g.tick_params("x", rotation=options.x_labels_rotation)
        # format the labels with f-strings
        for ax in g.axes.flat:
            ax.yaxis.set_major_formatter('{x}' + f' {common_unit}')
        if options.y_starts_at_zero:
            _, top = plt.ylim()
            plt.ylim(bottom=0, top=top * 1.10)  # Add 10% headroom
        plt.savefig(graphfile, format=output_format)
        plt.close()  # Close the figure to free memory
        graphfile.flush()
